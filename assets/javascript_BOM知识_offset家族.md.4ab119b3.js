import{_ as a,c as t,o as e,a as s}from"./app.5b8334ac.js";const f="/assets/b3.8c51a709.png";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"1. offsetHeight和offsetWidth （包含滚动条）","slug":"_1-offsetheight和offsetwidth-包含滚动条","link":"#_1-offsetheight和offsetwidth-包含滚动条","children":[]},{"level":3,"title":"2.offsetLeft和offsetTop（只读）","slug":"_2-offsetleft和offsettop-只读","link":"#_2-offsetleft和offsettop-只读","children":[]},{"level":3,"title":"3.offsetParent","slug":"_3-offsetparent","link":"#_3-offsetparent","children":[]}],"relativePath":"javascript/BOM知识/offset家族.md","lastUpdated":1685584113000}'),d={name:"javascript/BOM知识/offset家族.md"},o=s('<img src="'+f+'" data-v-34119a40><h3 id="_1-offsetheight和offsetwidth-包含滚动条" tabindex="-1" data-v-34119a40>1. offsetHeight和offsetWidth （包含滚动条） <a class="header-anchor" href="#_1-offsetheight和offsetwidth-包含滚动条" aria-hidden="true" data-v-34119a40>#</a></h3><div class="a" data-v-34119a40>获取盒子的高度宽度，包括内容区、内边距、边框（不计算滚动、超过隐藏的部分）</div><div class="text1" data-v-34119a40>表示元素的 CSS 垂直高度（单位像素,不计算滚动、超过隐藏的部分），包括元素本身的高度、padding 和 border， <span class="r" data-v-34119a40>以及水平滚动条的高度（如果存在滚动条）</span><span class="r" data-v-34119a40>针对块级、内联元素都行</span></div><div class="list" data-v-34119a40>offsetWidth: css的宽度(不包括溢出的宽度) + padding + border</div><div class="list" data-v-34119a40>offsetHeight: css的高度(不包括溢出的高度) + padding + border</div><h3 id="_2-offsetleft和offsettop-只读" tabindex="-1" data-v-34119a40>2.offsetLeft和offsetTop（只读） <a class="header-anchor" href="#_2-offsetleft和offsettop-只读" aria-hidden="true" data-v-34119a40>#</a></h3><div class="a" data-v-34119a40>当前元素和定位父元素之间的偏移量（如果没有设置定位父元素，就是相对于左上角的位置,top是距离顶部的距离,left是最左边的距离） offsetLeft水平偏移量 offsetTop垂直偏移量,是以offsetParent的padding做外层为基准</div><div class="list" data-v-34119a40>获取距离第一个有定位的父级盒子左边和上边的距离，注意：父级盒子必须要有定位，如果没有， <span class="r" data-v-34119a40>则最终以body为准</span></div><div class="list" data-v-34119a40>offsetLeft: 获取距离第一个有定位的父级盒子左边的距离,是以offsetParent的padding做外层为基准</div><div class="list" data-v-34119a40>offsetTop: 获取距离第一个有定位的父级盒子上边的距离。是以offsetParent的padding做外层为基准</div><div class="list red" data-v-34119a40>offsetLeft = 父元素的padding-left+子元素的margin-left（不设置子元素绝对定位的情况下）</div><div class="list red" data-v-34119a40>offsetLeft = 子元素的left值+子元素的margin-left（设置子元素绝对定位的情况下）</div><div class="list red" data-v-34119a40>offsetTop = 父元素的padding-top+子元素的margin-top（不设置子元素绝对定位的情况下）</div><div class="list red" data-v-34119a40>offsetTop = 子元素的top值+子元素的margin-top（设置子元素绝对定位的情况下）</div><p data-v-34119a40><span class="r" data-v-34119a40>三大家族中只有scroll有动态变化的数据，offsetLeft、offsetTop是进页面后固定的，不会随着滚动而改变大小</span></p><h3 id="_3-offsetparent" tabindex="-1" data-v-34119a40>3.offsetParent <a class="header-anchor" href="#_3-offsetparent" aria-hidden="true" data-v-34119a40>#</a></h3><div class="a" data-v-34119a40> 返回当前对象的父级（带有定位）盒子，可能是父亲、也可能是爷爷 <p data-v-34119a40>如果当前元素的父级元素没有进行CSS定位（position：absolute 或 relative），则其offsetParent为body； 如果当前元素的父级元素中有CSS定位（position：absolute或relative），offsetParent取最近的那个父级元素。</p></div><p data-v-34119a40><span class="r" data-v-34119a40></span></p>',19),i=[o];function l(r,n,p,v,c,_){return e(),t("div",null,i)}const m=a(d,[["render",l],["__scopeId","data-v-34119a40"]]);export{g as __pageData,m as default};
